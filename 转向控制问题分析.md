# 转向控制问题分析报告

## 发现的问题

### 1. **边界距离计算错误**
**位置**: `rule_based_agent.py:351-352`

```python
# 当前代码（有问题）：
margin_r = abs(ey_now - lo)    # 🚨 问题：右边界距离计算错误
margin_l = abs(up - ey_now)    # ✅ 正确：左边界距离计算
```

**问题分析**：
- `lo` 是下边界（右侧），`up` 是上边界（左侧）
- `ey_now - lo` 当车在中间时为正值，但当车偏右时可能为负值
- 使用 `abs()` 后无法区分车是在边界内还是外

**正确计算应该是**：
```python
margin_r = ey_now - lo         # 距右边界的有向距离（正值=在边界内）
margin_l = up - ey_now         # 距左边界的有向距离（正值=在边界内）
```

### 2. **航向误差计算可能不稳定**
**位置**: `rule_based_agent.py:367-371`

```python
# 当前代码：
ds_yaw = 1.0
x_fwd, y_fwd = self.ref.se2xy(s_q + ds_yaw, 0.0)
yaw_ref = np.arctan2(y_fwd - y, x_fwd - x)
```

**潜在问题**：
- 当 `ds_yaw = 1.0` 太小时，`(x_fwd-x, y_fwd-y)` 向量很短，角度计算不稳定
- 当车辆不在参考线中心时，计算的航向可能有偏差

### 3. **转向映射公式可能不准确**
**位置**: `rule_based_agent.py:392-393`

```python
# 当前代码：
steer = float(np.clip(delta_cmd / 0.5, -1.0, 1.0))
```

**问题**：
- 假设最大前轮角是 0.5 弧度（≈28.6°）
- 但不同车型的最大前轮角可能不同
- CARLA的steer参数可能不是线性映射

### 4. **控制增益可能过大**
**位置**: `rule_based_agent.py:375-378`

```python
Ky0 = 0.9       # 横向位置增益
Kpsi0 = 1.5     # 航向增益
```

**问题**：
- 增益值相对较大，可能导致振荡
- 速度衰减因子 `0.05` 可能不够

## 修复建议

### 修复1：边界距离计算
```python
# 修正边界距离计算
margin_r = ey_now - lo      # 距右边界距离（正=在内，负=出界）
margin_l = up - ey_now      # 距左边界距离（正=在内，负=出界）

# 修正偏置逻辑
bias = 0.0
if margin_r < bias_zone and margin_r <= margin_l:
    # 靠近右边界，往左偏
    bias = +bias_gain * (bias_zone - margin_r)
elif margin_l < bias_zone and margin_l < margin_r:
    # 靠近左边界，往右偏
    bias = -bias_gain * (bias_zone - margin_l)
```

### 修复2：航向误差计算稳定性
```python
# 增大采样距离，提高数值稳定性
ds_yaw = max(2.0, speed * 0.5)  # 动态调整采样距离
x_fwd, y_fwd = self.ref.se2xy(s_q + ds_yaw, 0.0)

# 添加有效性检查
dx, dy = x_fwd - x, y_fwd - y
if math.hypot(dx, dy) < 0.1:  # 距离太近时使用默认值
    e_psi = 0.0
else:
    yaw_ref = np.arctan2(dy, dx)
    e_psi = np.arctan2(np.sin(yaw_ref - yaw_rad), np.cos(yaw_ref - yaw_rad))
```

### 修复3：转向映射改进
```python
# 更保守的转向映射
max_front_wheel_angle = 0.4  # 减小最大转角
steer = float(np.clip(delta_cmd / max_front_wheel_angle, -1.0, 1.0))

# 或者使用非线性映射
steer_raw = delta_cmd / 0.5
steer = float(np.clip(np.tanh(steer_raw), -1.0, 1.0))  # 平滑限制
```

### 修复4：控制参数调优
```python
# 更保守的控制增益
Ky0 = 0.6       # 降低横向增益
Kpsi0 = 1.0     # 降低航向增益

# 增强速度衰减
Ky = Ky0 / (1.0 + 0.1 * max(0.0, speed))      # 增大衰减因子
Kpsi = Kpsi0 / (1.0 + 0.08 * max(0.0, speed))
```

## 完整修复代码

```python
def compute_control(self, obs: dict, dt: float = 0.05) -> tuple:
    # ... 前面代码保持不变 ...

    # —— 修复1：正确计算边界距离 —— #
    margin_r = ey_now - lo      # 距右边界有向距离
    margin_l = up - ey_now      # 距左边界有向距离

    # 偏置计算（基于有向距离）
    bias_gain = 0.25            # 降低偏置强度
    bias_zone = 0.40
    bias = 0.0

    if margin_r < bias_zone and margin_r >= 0 and margin_r <= margin_l:
        bias = +bias_gain * (bias_zone - margin_r)
    elif margin_l < bias_zone and margin_l >= 0 and margin_l < margin_r:
        bias = -bias_gain * (bias_zone - margin_l)

    ey_ref = 0.5 * (lo + up) + bias
    e_y = ey_ref - ey_now

    # —— 修复2：稳定的航向误差计算 —— #
    ds_yaw = max(2.0, speed * 0.3)
    x_fwd, y_fwd = self.ref.se2xy(s_q + ds_yaw, 0.0)
    dx, dy = x_fwd - x, y_fwd - y

    if math.hypot(dx, dy) < 0.1:
        e_psi = 0.0
    else:
        yaw_ref = np.arctan2(dy, dx)
        e_psi = np.arctan2(np.sin(yaw_ref - yaw_rad), np.cos(yaw_ref - yaw_rad))

    # —— 修复3：更保守的控制增益 —— #
    Ky0 = 0.6
    Kpsi0 = 1.0
    Ky = Ky0 / (1.0 + 0.1 * max(0.0, speed))
    Kpsi = Kpsi0 / (1.0 + 0.08 * max(0.0, speed))

    # 边界guard计算（基于绝对距离）
    min_margin = min(abs(margin_l), abs(margin_r))
    guard = 1.0 + 0.6 * np.exp(-min_margin / 0.25)

    delta_cmd = guard * (Ky * e_y + Kpsi * e_psi)

    # 限幅和变化率限制
    delta_cmd = float(np.clip(delta_cmd, -0.3, 0.3))  # 更保守的限制

    if not hasattr(self, "_prev_delta"):
        self._prev_delta = 0.0
    max_d_delta = np.deg2rad(45.0) * dt  # 降低变化率限制
    d_delta = float(np.clip(delta_cmd - self._prev_delta, -max_d_delta, +max_d_delta))
    delta_cmd = self._prev_delta + d_delta
    self._prev_delta = delta_cmd

    # —— 修复4：改进的转向映射 —— #
    max_wheel_angle = 0.35
    steer_raw = delta_cmd / max_wheel_angle
    steer = float(np.clip(steer_raw, -1.0, 1.0))

    # ... 其余代码保持不变 ...
```

## 调试建议

1. **添加调试输出**：
```python
print(f"[STEER] ey={ey_now:.3f}, lo={lo:.3f}, up={up:.3f}")
print(f"[STEER] margin_l={margin_l:.3f}, margin_r={margin_r:.3f}")
print(f"[STEER] e_y={e_y:.3f}, e_psi={e_psi:.3f}, delta={delta_cmd:.3f}, steer={steer:.3f}")
```

2. **监控关键指标**：
- 边界距离是否合理
- 航向误差是否平滑
- 转向命令是否振荡

3. **参数调优**：
- 先降低控制增益，确保稳定性
- 再逐步调高，提升响应性
- 观察实际转向效果调整映射参数