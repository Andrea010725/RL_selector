# CARLA 障碍物边界检测与路径规划技术文档

## 概述

本文档详细介绍了基于CARLA仿真器的障碍物边界检测、路径规划和车辆控制系统。该系统采用Frenet坐标系进行路径规划，结合动态规划算法生成安全走廊，实现自动驾驶车辆的智能避障和路径跟踪。

## 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   CARLA World   │───▶│  障碍物检测模块  │───▶│   路径规划模块   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   可视化模块    │◀───│   坐标转换模块   │◀───│   车辆控制模块   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 1. 障碍物边界检测系统

### 1.1 核心检测函数：`collect_obstacles_local`

**文件位置**: `planning/obstacles.py`

```python
def collect_obstacles_local(
    world: carla.World,           # CARLA世界对象
    ego: carla.Actor,            # 自车对象
    ref_xy2se,                   # 坐标转换函数：世界坐标→Frenet坐标
    s_center: float,             # 当前纵向位置
    s_back: float = 10.0,        # 向后检测距离(米)
    s_fwd: float = 20.0,         # 向前检测距离(米)
    r_xy: float = 35.0,          # 横向检测半径(米)
    horizon_T: float = 2.0,      # 动态障碍物预测时间(秒)
    dt: float = 0.2,            # 预测时间步长(秒)
) -> List[Tuple[float, float]]: # 返回：[(s, ey), ...]
```

### 1.2 障碍物检测流程

#### 步骤1：障碍物候选筛选

```python
def _is_candidate(actor: carla.Actor) -> bool:
    """判断actor是否为障碍物候选"""
    tid = actor.type_id.lower()

    # 优先匹配：车辆、行人、静态物体等
    if any(tid.startswith(p) for p in INCLUDE_PREFIXES):
        return True

    # 兜底机制：检查包围盒大小
    bb = getattr(actor, "bounding_box", None)
    if bb:
        ex, ey = bb.extent.x, bb.extent.y
        return (ex <= 4.0 and ey <= 4.0)  # 小型到中型物体

    return False

# 包含的对象类型前缀
INCLUDE_PREFIXES = (
    "vehicle.",      # 车辆
    "walker.",       # 行人
    "static.",       # 静态物体
    "traffic.",      # 交通设施
    "prop.",         # 道具
    "construction.", # 建筑
    "barrier."       # 护栏
)
```

#### 步骤2：距离和存活性过滤

```python
for a in actors:
    # 存活性检查
    if not _alive(a):
        continue

    # 排除自车和hero角色
    if a.id == ego.id or a.attributes.get("role_name", "") in EXCLUDE_ROLE_NAMES:
        continue

    # 候选性检查
    if not _is_candidate(a):
        continue

    # 距离预筛选（欧氏距离）
    loc = a.get_transform().location
    dx, dy = loc.x - ex, loc.y - ey
    if dx * dx + dy * dy > r_xy * r_xy:
        continue
```

#### 步骤3：动态与静态障碍物分别处理

**动态障碍物处理**（车辆、行人）：
```python
if is_dynamic:
    vel = a.get_velocity()
    x0, y0, vx, vy = loc.x, loc.y, vel.x, vel.y

    # 常速外推预测
    steps = max(1, int(horizon_T / dt))
    for k in range(steps + 1):
        t = k * dt
        x, y = x0 + vx * t, y0 + vy * t  # 预测位置
        s, eyy = ref_xy2se(x, y)         # 转换为Frenet坐标
        if s_min <= s <= s_max:
            pts_se.append((s, eyy))
```

**静态障碍物处理**（建筑物、锥桶等）：
```python
else:
    # 使用包围盒足迹点采样
    for (x, y) in _footprint_points(a, density=0.4):
        s, eyy = ref_xy2se(x, y)
        if s_min <= s <= s_max:
            pts_se.append((s, eyy))
```

### 1.3 包围盒足迹点生成

```python
def _footprint_points(actor: carla.Actor, density: float = 0.5) -> List[Tuple[float, float]]:
    """生成actor包围盒在世界坐标系下的密集采样点"""

    bb = getattr(actor, "bounding_box", None)
    tf = actor.get_transform()

    if not bb:
        return [(tf.location.x, tf.location.y)]  # 退化为单点

    # 获取包围盒四个角点（局部坐标）
    ex, ey = bb.extent.x, bb.extent.y
    local_corners = [(+ex, +ey, 0.0), (+ex, -ey, 0.0),
                     (-ex, -ey, 0.0), (-ex, +ey, 0.0)]

    # 转换为世界坐标
    yaw = math.radians(tf.rotation.yaw)
    c, s = math.cos(yaw), math.sin(yaw)
    world_corners = []
    for (lx, ly, _lz) in local_corners:
        wx = tf.location.x + c * lx - s * ly
        wy = tf.location.y + s * lx + c * ly
        world_corners.append((wx, wy))

    # 沿四边插值采样，保证密度
    densified = []
    for i in range(4):
        for p in _interpolate_edge(world_corners[i], world_corners[(i + 1) % 4], density):
            densified.append(p)

    return densified
```

## 2. 坐标系统与参考线

### 2.1 Frenet坐标系

本系统使用Frenet坐标系进行路径规划：
- **s (纵向坐标)**: 沿参考线的弧长距离
- **ey (横向坐标)**: 垂直于参考线的横向偏移

### 2.2 参考线生成：`LaneRef`类

**文件位置**: `agents/rule_based/rule_based_agent.py`

```python
class LaneRef:
    """沿车道中心线构建参考线，提供世界坐标↔Frenet坐标转换"""

    def __init__(self, amap: carla.Map, seed_wp: carla.Waypoint,
                 step: float = 1.0, max_len: float = 500.0):
        """
        基于种子waypoint沿同一车道采样生成参考线

        参数:
            amap: CARLA地图对象
            seed_wp: 起始waypoint（通常为第一个锥桶位置对应的车道中心）
            step: 采样间距(米)
            max_len: 参考线最大长度(米)
        """
        pts, wps = [], []
        wp = seed_wp
        dist = 0.0

        # 保持在同一车道内
        guard_ids = (wp.road_id, wp.section_id, wp.lane_id)

        # 沿车道中心线采样
        while dist < max_len:
            pts.append((wp.transform.location.x, wp.transform.location.y))
            wps.append(wp)

            nxts = wp.next(step)
            if not nxts:
                break
            wp = nxts[0]

            # 检查是否仍在同一车道
            if (wp.road_id, wp.section_id, wp.lane_id) != guard_ids:
                break

            dist += step

        # 计算弧长和切线方向
        self.P = np.asarray(pts, dtype=float)  # [N,2] 参考线点
        d = np.linalg.norm(np.diff(self.P, axis=0), axis=1)
        self.s = np.concatenate([[0.0], np.cumsum(d)])  # [N] 弧长

        # 计算单位切向量
        tang = np.diff(self.P, axis=0)
        tang = np.vstack([tang, tang[-1]])
        self.tang = tang / (np.linalg.norm(tang, axis=1, keepdims=True) + 1e-9)
```

### 2.3 坐标转换函数

```python
def xy2se(self, x: float, y: float) -> Tuple[float, float]:
    """世界坐标 → Frenet坐标"""

    # 找到最近的参考线段
    i, t, proj = self._segment_index_and_t(x, y)

    # 计算纵向坐标s
    s_val = self.s[i] + t * (self.s[i+1] - self.s[i])

    # 计算横向坐标ey（左法向为正）
    tx, ty = self.tang[i]
    nx, ny = -ty, tx  # 左法向量
    ey = (x - proj[0]) * nx + (y - proj[1]) * ny

    return float(s_val), float(ey)

def se2xy(self, s: float, ey: float) -> Tuple[float, float]:
    """Frenet坐标 → 世界坐标"""

    # 在参考线上插值找到基点
    s = float(np.clip(s, self.s[0], self.s[-1]))
    i = int(np.searchsorted(self.s, s) - 1)
    i = max(0, min(i, len(self.s)-2))

    ratio = (s - self.s[i]) / max(1e-9, self.s[i+1]-self.s[i])
    base = self.P[i] * (1 - ratio) + self.P[i+1] * ratio

    # 沿左法向偏移ey距离
    tx, ty = self.tang[i]
    nx, ny = -ty, tx
    x = base[0] + ey * nx
    y = base[1] + ey * ny

    return float(x), float(y)
```

## 3. 动态规划走廊生成

### 3.1 DPCorridor类架构

**文件位置**: `planning/dp_corridor.py`

```python
class DPCorridor:
    """动态规划风格的安全走廊构造器"""

    def __init__(self, s_max=120.0, ds=2.0, ey_span=3.0, dey=0.2,
                 obs_sigma=0.6, smooth_w=0.05, max_step=2):
        """
        参数:
            s_max: 纵向网格最大长度(米)
            ds: 纵向网格分辨率(米)
            ey_span: 横向网格半宽(米)
            dey: 横向网格分辨率(米)
            obs_sigma: 障碍物影响标准差(米)
            smooth_w: 平滑系数
            max_step: 最大步长限制
        """
        self.s_grid = np.arange(0.0, s_max + 1e-6, ds)      # [K] 纵向网格
        self.ey_grid = np.arange(-ey_span, ey_span + 1e-6, dey)  # [M] 横向网格
```

### 3.2 代价图构建

#### 步骤1：障碍物软代价计算

```python
def build_cost_map_general(self, world, ego_actor, ref_xy2se, s_center,
                          s_back=10.0, s_fwd=20.0, sigma_s=2.5, sigma_y=0.6,
                          horizon_T=2.0, dt=0.2) -> np.ndarray:
    """构建障碍物软代价图"""

    K, M = len(self.s_grid), len(self.ey_grid)
    cost = np.zeros((K, M), dtype=float)

    # 收集障碍物点
    pts_se = collect_obstacles_local(
        world=world, ego=ego_actor, ref_xy2se=ref_xy2se,
        s_center=s_center, s_back=s_back, s_fwd=s_fwd,
        r_xy=35.0, horizon_T=horizon_T, dt=dt
    )

    # 为每个障碍物点添加2D高斯代价
    half_ws = max(1, int(round(sigma_s / max(1e-6, self.ds)) * 3))
    half_wy = max(1, int(round(sigma_y / max(1e-6, self.dey)) * 3))

    for (s_ob, ey_ob) in pts_se:
        # 找到对应的网格索引
        si = int(np.clip(round((s_ob - s0) / self.ds), 0, K - 1))
        yi = int(np.clip(round((ey_ob - y0) / self.dey), 0, M - 1))

        # 计算影响范围
        s_lo = max(0, si - half_ws)
        s_hi = min(K - 1, si + half_ws)
        y_lo = max(0, yi - half_wy)
        y_hi = min(M - 1, yi + half_wy)

        # 应用2D高斯核
        S = self.s_grid[s_lo:s_hi + 1][:, None]
        Y = self.ey_grid[y_lo:y_hi + 1][None, :]
        gs = np.exp(-0.5 * ((S - s_ob) / max(1e-6, sigma_s)) ** 2)
        gy = np.exp(-0.5 * ((Y - ey_ob) / max(1e-6, sigma_y)) ** 2)
        cost[s_lo:s_hi + 1, y_lo:y_hi + 1] += gs * gy

    return cost
```

#### 步骤2：走廊边界提取

```python
def run_dp(self, cost_map: np.ndarray, row_percentile=60.0,
           min_width=1.8, safety_margin=0.20) -> Corridor:
    """基于代价图提取可行走廊"""

    K, M = cost_map.shape
    s, ey = self.s_grid, self.ey_grid
    lower, upper = np.full(K, ey[0]), np.full(K, ey[-1])

    # 按行计算代价阈值
    tau_row = np.percentile(cost_map, row_percentile, axis=1)
    zero_idx = int(np.clip(round((0.0 - ey[0]) / self.dey), 0, M - 1))

    for k in range(K):
        row = cost_map[k, :]
        tau = tau_row[k]

        # 二值化：低代价区域为可行
        free = row < tau

        # 扫描连续可行段
        segments = []
        i = 0
        while i < M:
            if free[i]:
                j = i
                while j + 1 < M and free[j + 1]:
                    j += 1
                segments.append((i, j))
                i = j + 1
            else:
                i += 1

        if not segments:
            # 无可行段时使用默认宽度
            continue

        # 优先选择包含ey=0的段，否则选最宽段
        chosen = None
        for (i0, i1) in segments:
            if i0 <= zero_idx <= i1:
                chosen = (i0, i1)
                break
        if chosen is None:
            chosen = max(segments, key=lambda seg: seg[1] - seg[0])

        # 计算边界并加安全余量
        i0, i1 = chosen
        lo = ey[i0] - safety_margin
        up = ey[i1] + safety_margin

        # 最小宽度保障
        if up - lo < min_width:
            mid = 0.5 * (lo + up)
            lo = mid - 0.5 * min_width
            up = mid + 0.5 * min_width

        # 边界裁剪
        lo = max(lo, ey[0])
        up = min(up, ey[-1])

        lower[k], upper[k] = lo, up

    return Corridor(s.copy(), lower, upper)
```

### 3.3 硬边界墙约束

```python
@staticmethod
def walls_from_points(pts_se, s_grid, ds, safety=0.25):
    """根据障碍物点生成硬边界墙"""

    K = len(s_grid)
    left_wall = np.full(K, +np.inf)   # 左侧墙（ey > 0）
    right_wall = np.full(K, -np.inf)  # 右侧墙（ey < 0）
    s0 = float(s_grid[0])

    # 为每个纵向位置找到最近的左右障碍物
    for (s, ey) in pts_se:
        k = int(np.clip(round((s - s0) / max(1e-6, ds)), 0, K - 1))
        if ey >= 0.0:
            left_wall[k] = min(left_wall[k], ey)   # 左侧最近障碍物
        else:
            right_wall[k] = max(right_wall[k], ey) # 右侧最近障碍物

    # 线性插值填补空缺 + 平滑处理
    left_wall = _smooth(_interpolate(left_wall)) - safety
    right_wall = _smooth(_interpolate(right_wall)) + safety

    return left_wall, right_wall
```

## 4. 路径规划整合

### 4.1 走廊更新流程

**文件位置**: `agents/rule_based/rule_based_agent.py`

```python
def update_corridor(self, world, ego=None, debug_draw_points=True):
    """更新安全走廊"""

    if ego is None:
        self.corridor = None
        return

    # === 1) 设置滑动窗口 ===
    ego_tf = ego.get_transform()
    s_center, _ = self.ref.xy2se(ego_tf.location.x, ego_tf.location.y)
    s_lo, s_hi = s_center - 10.0, s_center + 20.0

    # 让DP的s_grid跟随自车移动
    self.dp.set_window(s0=s_lo, length_m=(s_hi - s_lo))

    # === 2) 收集障碍物点 ===
    pts_se = collect_obstacles_local(
        world=world, ego=ego, ref_xy2se=self.ref.xy2se,
        s_center=s_center, s_back=10.0, s_fwd=20.0,
        r_xy=35.0, horizon_T=2.0, dt=0.2
    )

    # === 3) 构建软代价图并运行DP ===
    cost = self.dp.build_cost_map_general(
        world=world, ego_actor=ego, ref_xy2se=self.ref.xy2se,
        s_center=s_center, s_back=10.0, s_fwd=20.0,
        sigma_s=2.5, sigma_y=0.6, horizon_T=2.0, dt=0.2
    )

    corridor = self.dp.run_dp(
        cost_map=cost, row_percentile=60.0,
        min_width=1.8, safety_margin=0.20
    )

    # === 4) 硬边界约束 ===
    if len(pts_se) > 0:
        left_wall, right_wall = self.dp.walls_from_points(
            pts_se, corridor.s, self.dp.ds, safety=0.25
        )

        # 约束走廊边界
        lo = np.maximum(corridor.lower, right_wall)
        up = np.minimum(corridor.upper, left_wall)

        # 最小宽度保障 + 平滑
        bad = (up - lo) < 1.5
        if np.any(bad):
            mid = 0.5 * (up + lo)
            lo[bad] = mid[bad] - 0.75
            up[bad] = mid[bad] + 0.75

        # 轻量平滑
        lo = 0.5 * lo + 0.5 * np.r_[lo[:1], lo[:-1]]
        up = 0.5 * up + 0.5 * np.r_[up[:1], up[:-1]]

        corridor.lower, corridor.upper = lo, up

    self.corridor = corridor
```

## 5. 车辆控制系统

### 5.1 规则控制器：`RuleBasedPlanner`

```python
class RuleBasedPlanner:
    """规则型路径跟踪控制器"""

    def __init__(self, dp: DPCorridor, ref: LaneRef,
                 v_ref_base=12.0, dp_interval=8):
        """
        参数:
            dp: 动态规划走廊生成器
            ref: 参考线对象
            v_ref_base: 基础目标速度(m/s)
            dp_interval: 走廊更新间隔(帧)
        """
        self.dp = dp
        self.ref = ref
        self.v_ref_base = v_ref_base
        self.dp_interval = dp_interval
        self._prev_delta = 0.0  # 前轮转角历史
        self._prev_ax = 0.0     # 加速度历史
```

### 5.2 控制计算流程

```python
def compute_control(self, obs: dict, dt: float = 0.05) -> tuple:
    """计算油门、转向、刹车控制量"""

    # === 1) 提取车辆状态 ===
    ego_pose = obs.get("ego_pose", {})
    ego_v = obs.get("ego_v", {})
    x, y = float(ego_pose.get("x", 0.0)), float(ego_pose.get("y", 0.0))
    yaw_deg = float(ego_pose.get("yaw", 0.0))
    speed = float(ego_v.get("speed", 0.0))
    yaw_rad = np.deg2rad(yaw_deg)

    # === 2) 计算Frenet位姿 ===
    s_now, ey_now = self.ref.xy2se(x, y)

    # === 3) 插值走廊边界 ===
    if self.corridor is None:
        lo, up = -1.5, 1.5  # 默认走廊
    else:
        s_min, s_max = self.corridor.s[0], self.corridor.s[-1]
        s_q = float(np.clip(s_now, s_min, s_max))
        lo = float(np.interp(s_q, self.corridor.s, self.corridor.lower))
        up = float(np.interp(s_q, self.corridor.s, self.corridor.upper))

    # 边界合理性检查
    if lo > up:
        lo, up = up, lo
    width = max(1e-3, up - lo)

    # === 4) 目标横向位置计算（带偏置） ===
    margin_r = abs(ey_now - lo)  # 距右边界距离
    margin_l = abs(up - ey_now)  # 距左边界距离

    # 靠墙偏置：距墙近时目标点向远离墙方向偏移
    bias_gain = 0.35
    bias_zone = 0.40
    bias = 0.0

    if margin_r < bias_zone and margin_r <= margin_l:
        bias = +bias_gain * (bias_zone - margin_r)  # 向左偏
    elif margin_l < bias_zone and margin_l < margin_r:
        bias = -bias_gain * (bias_zone - margin_l)  # 向右偏

    ey_ref = 0.5 * (lo + up) + bias  # 带偏置的目标横向位置
    e_y = ey_ref - ey_now            # 横向误差

    # === 5) 航向误差计算 ===
    # 基于参考线切线方向
    ds_yaw = 1.0
    x_fwd, y_fwd = self.ref.se2xy(s_q + ds_yaw, 0.0)
    yaw_ref = np.arctan2(y_fwd - y, x_fwd - x)
    e_psi = np.arctan2(np.sin(yaw_ref - yaw_rad), np.cos(yaw_ref - yaw_rad))

    # === 6) 横向控制（PD控制 + 边界增强） ===
    Ky0, Kpsi0 = 0.9, 1.5
    Ky = Ky0 / (1.0 + 0.05 * max(0.0, speed))      # 速度衰减增益
    Kpsi = Kpsi0 / (1.0 + 0.05 * max(0.0, speed))

    # 边界守护增益（越靠边界增益越大）
    guard = 1.0 + 0.8 * np.exp(-min(margin_l, margin_r) / 0.30)

    delta_cmd = guard * (Ky * e_y + Kpsi * e_psi)  # 前轮转角命令

    # 转角限幅 + 变化率限制
    delta_cmd = float(np.clip(delta_cmd, -0.35, 0.35))
    max_d_delta = np.deg2rad(60.0) * dt
    d_delta = np.clip(delta_cmd - self._prev_delta, -max_d_delta, +max_d_delta)
    delta_cmd = self._prev_delta + d_delta
    self._prev_delta = delta_cmd

    # 映射到CARLA转向 [-1,1]
    steer = float(np.clip(delta_cmd / 0.5, -1.0, 1.0))

    # === 7) 纵向控制（自适应速度） ===
    # 基于走廊宽度的速度调节
    v_base = float(self.v_ref_base)
    v_ref_w = np.clip(v_base * (width / 3.0), 6.0, v_base)

    # 基于距墙距离的进一步降速
    shrink = 1.0
    near = min(margin_l, margin_r)
    if near < 0.6:
        shrink = max(0.4, near / 0.6)
    v_ref = v_ref_w * shrink

    # 加速度P控制 + 限幅 + 变化率限制
    ax_cmd = 0.8 * (v_ref - speed)
    ax_cmd = float(np.clip(ax_cmd, -3.0, 2.0))

    max_d_ax = 3.0 * dt
    d_ax = np.clip(ax_cmd - self._prev_ax, -max_d_ax, +max_d_ax)
    ax = self._prev_ax + d_ax
    self._prev_ax = ax

    # === 8) 油门/刹车映射 ===
    if ax >= 0.0:
        throttle, brake = ax / 2.0, 0.0
    else:
        throttle, brake = 0.0, (-ax) / 3.0

    throttle = float(np.clip(throttle, 0.0, 1.0))
    brake = float(np.clip(brake, 0.0, 1.0))

    # === 9) 调试信息 ===
    debug_info = {
        'mode': 'DP-corridor + RuleMidline + bias + heading',
        's': s_now, 's_q': s_q, 'ey': ey_now,
        'lo': lo, 'up': up, 'width': width,
        'ey_ref': ey_ref, 'e_y': e_y, 'e_psi': e_psi,
        'v': speed, 'v_ref': v_ref, 'ax': ax,
        'delta': delta_cmd, 'throttle': throttle,
        'brake': brake, 'steer': steer,
        'margin_l': margin_l, 'margin_r': margin_r
    }

    return throttle, steer, brake, debug_info
```

## 6. 可视化系统

### 6.1 障碍物可视化

**文件位置**: `agents/rule_based/vis_debug.py`

```python
def draw_obstacles_samples(world: carla.World, ref, world_points,
                          color=(255, 0, 0), lifetime=0.2):
    """绘制障碍物采样点"""
    for (x, y) in world_points:
        wp = world.get_map().get_waypoint(carla.Location(x=x, y=y, z=0.0),
                                         project_to_road=True)
        z = (wp.transform.location.z if wp else 0.0) + 0.05
        world.debug.draw_point(carla.Location(x=x, y=y, z=z),
                              size=0.08, color=carla.Color(*color),
                              life_time=lifetime)

def draw_pts_se(world, ref, pts_se, color=(255,0,0), size=0.08, life=0.6):
    """绘制Frenet坐标下的障碍点"""
    for (s, ey) in pts_se:
        x, y = ref.se2xy(s, ey)
        z = world.get_map().get_waypoint(carla.Location(x=x, y=y),
                                        project_to_road=True).transform.location.z + 0.05
        world.debug.draw_point(carla.Location(x=x, y=y, z=z),
                              size=size, color=carla.Color(*color), life_time=life)
```

### 6.2 走廊边界可视化

```python
def draw_corridor(world: carla.World, ref, corridor,
                 color_lo=(0,255,0), color_up=(0,255,0), color_mid=(255,255,0),
                 lifetime=0.2):
    """绘制安全走廊边界"""
    if corridor is None:
        return

    s = corridor.s
    lo, up = corridor.lower, corridor.upper
    mid = 0.5 * (lo + up)

    def _draw_boundary(ey_arr, rgb):
        prev = None
        for si, eyi in zip(s, ey_arr):
            x, y = ref.se2xy(float(si), float(eyi))
            wp = world.get_map().get_waypoint(carla.Location(x=x, y=y, z=0.0),
                                            project_to_road=True)
            z = (wp.transform.location.z if wp else 0.0) + 0.10
            loc = carla.Location(x=x, y=y, z=z)

            if prev is not None:
                world.debug.draw_line(prev, loc, thickness=0.1,
                                    color=carla.Color(*rgb), life_time=lifetime)
            prev = loc

    _draw_boundary(lo, color_lo)    # 下边界
    _draw_boundary(up, color_up)    # 上边界
    _draw_boundary(mid, color_mid)  # 中线
```

## 7. 主流程集成

### 7.1 完整流程

**文件位置**: `agents/rule_based/rule_based_agent.py`

```python
def main():
    """主控制循环"""

    # === 1) 连接CARLA并设置场景 ===
    env = HighwayEnv(host="127.0.0.1", port=2000, sync=True, fixed_dt=0.05).connect()
    env.setup_scene(num_cones=10, step_forward=3.0, step_right=0.30)

    # === 2) 生成自车 ===
    ego = spawn_ego_upstream_lane_center(env)

    # === 3) 构建参考线 ===
    first_tf = env.get_first_cone_transform()
    amap = env.world.get_map()
    seed_wp = amap.get_waypoint(first_tf.location, project_to_road=True,
                               lane_type=carla.LaneType.Driving)
    ref = LaneRef(amap, seed_wp=seed_wp, step=1.0, max_len=500.0)

    # === 4) 初始化规划器 ===
    dp = DPCorridor(s_max=120.0, ds=2.0, ey_span=3.0, dey=0.2,
                   obs_sigma=0.6, smooth_w=0.05, max_step=2)
    planner = RuleBasedPlanner(dp, ref, v_ref_base=12.0, dp_interval=8)

    # === 5) 主控制循环 ===
    logger = TelemetryLogger(out_dir="logs_rule_based")
    dt, frame = 0.05, 0

    while True:
        # 定期更新走廊
        if (planner.corridor is None) or (frame % planner.dp_interval == 0):
            planner.update_corridor(env.world, ego=env.ego)
            draw_corridor(env.world, ref, planner.corridor)

        # 仿真步进 + 控制计算
        obs, _ = env.step()
        throttle, steer, brake, debug = planner.compute_control(obs, dt=dt)

        # 应用控制 + 可视化
        env.apply_control(throttle=throttle, steer=steer, brake=brake)

        if frame % 2 == 0:
            ego_pose = obs.get("ego_pose", {})
            draw_ego_marker(env.world, ego_pose.get("x", 0.0), ego_pose.get("y", 0.0))

        # 数据记录
        logger.log(frame, obs, debug, ref)
        frame += 1
```

## 8. 系统特点与优势

### 8.1 技术特点

1. **多源障碍物检测**：支持动态车辆、静态建筑、交通设施等
2. **Frenet坐标系规划**：适应弯曲道路，便于横纵向解耦控制
3. **软硬边界结合**：软代价图保证平滑性，硬边界墙保证安全性
4. **自适应速度控制**：根据走廊宽度和障碍物距离动态调速
5. **实时可视化**：提供障碍物点、走廊边界、轨迹等多层次可视化

### 8.2 控制策略

1. **偏置中线跟踪**：靠墙时目标点向远离墙方向偏移
2. **边界增强控制**：越靠近边界控制增益越大
3. **速度衰减增益**：高速时降低转向灵敏度，提高稳定性
4. **变化率限制**：平滑转角和加速度变化，避免突变

### 8.3 应用场景

- 高速公路驾驶辅助
- 城市道路避障导航
- 建筑工地自动驾驶
- 港口无人运输
- 矿区自主作业

## 9. 调试与优化

### 9.1 关键参数调节

```python
# 障碍物检测参数
r_xy = 35.0          # 检测半径，影响计算量和感知范围
horizon_T = 2.0      # 预测时间，影响动态障碍物轨迹长度
dt = 0.2            # 预测步长，影响轨迹密度

# 代价图参数
sigma_s = 2.5       # 纵向影响范围，影响障碍物代价扩散
sigma_y = 0.6       # 横向影响范围，影响避障margin
row_percentile = 60.0  # 阈值分位数，影响走廊宽度

# 控制参数
Ky0 = 0.9          # 横向误差增益
Kpsi0 = 1.5        # 航向误差增益
bias_gain = 0.35   # 靠墙偏置强度
v_ref_base = 12.0  # 基础目标速度
```

### 9.2 常见问题排查

1. **障碍物检测不到**：
   - 检查 `_is_candidate` 过滤条件
   - 确认障碍物在检测半径内
   - 验证坐标转换函数正确性

2. **走廊过窄或过宽**：
   - 调整 `row_percentile` 参数
   - 检查 `min_width` 设置
   - 验证 `sigma_s/sigma_y` 参数

3. **控制振荡**：
   - 降低控制增益 `Ky0/Kpsi0`
   - 增强变化率限制
   - 检查传感器噪声

4. **速度过慢**：
   - 提高 `v_ref_base`
   - 调整走廊宽度阈值
   - 减小安全margin

---

*本文档详细描述了CARLA环境下基于障碍物边界检测的自动驾驶路径规划与控制系统。系统采用模块化设计，支持实时障碍物检测、动态走廊生成和智能避障控制，适用于多种自动驾驶应用场景。*